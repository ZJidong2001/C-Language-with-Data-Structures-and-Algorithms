#include <stdio.h>

//int main()  // 按位与 - 只要有0则为0
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b;
//	// 00000000000000000000000000000011 - 3
//	// 00000000000000000000000000000101 - 5
//	// 00000000000000000000000000000001 - 结果为1
//	printf("%d\n", c);
//
//	return 0;
//}

//int main()  // 按位或 - 只要有1则为1
//{
//	int a = 3;
//	int b = 5;
//	int c = a | b;
//	// 00000000000000000000000000000011 - 3
//	// 00000000000000000000000000000101 - 5
//	// 00000000000000000000000000000111 - 结果为7
//	printf("%d\n", c);
//
//	return 0;
//}

//int main()  // 按位异或 - 相同为0，相异为1
//{
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;
//	// 00000000000000000000000000000011 - 3
//	// 00000000000000000000000000000101 - 5
//	// 00000000000000000000000000000110 - 结果为6
//	printf("%d\n", c);
//
//	return 0;
//}

//int main()  // 赋值操作符
//{
//	int a = 10;  // 创建变量a，并且初始化为10
//	a = 20;  // 赋值（已经创建变量才叫赋值，上面叫初始化）
//
//	// 下面两种写法含义相同，得到的结果相同
//	a = a + 10;  // 赋值
//	a += 10;  // 复合赋值符
//
//	a = a - 8;  // 赋值
//	a -= 8;  // 复合赋值符
//
//	a = a >> 1;  // 赋值
//	a >>= 1;  // 复合赋值符
//
//	return 0;
//}

//int main()  // 逻辑反操作
//{
//	int a = 10;
//	printf("%d\n", !a);  // 输出结果为0
//
//	int b = 0;
//	printf("%d\n", !b);  // 输出结果为1，非0的数很多，我们规定!0为1
//
//	if (a)  // a为真，进入if语句
//	{
//
//	}
//
//	if (!a)  // a为假，进入if语句
//	{
//
//	}
//
//	return 0;
//}

//int main()  // 负值、正值
//{
//	int a = 10;
//	int b = -a;  // 负值
//	int c = +a;  // 正值，一般省略掉
//
//	return 0;
//}

//int main()  // 操作数的类型长度（以字节为单位）
//{
//	int a = 10;
//	printf("%d\n", sizeof(a));  // 4
//	printf("%d\n", sizeof(int));  // 4
//
//	return 0;
//}

//int main()  // 对一个数的二进制按位取反
//{
//	// 整数在内存中以二进制存储，二进制有3种表现形式：原码、反码、补码
//
//	// 有符号的整数：最高位是0，表示正整数；最高位是1，表示负整数
//	// 正整数：原码、反码、补码相同
//	// 负整数：原码、反码、补码是需要计算的
//
//	// int a = 1;  // 4个字节 - 32bit
//	// 00000000000000000000000000000001 - 原码
//	// 00000000000000000000000000000001 - 反码
//	// 00000000000000000000000000000001 - 补码
//
//	// int a = -1;
//	// 10000000000000000000000000000001 - 原码
//	// 11111111111111111111111111111110 - 反码（原码的符号位不变，其他位按位取反，得到反码）
//	// 11111111111111111111111111111111 - 补码（反码的二进制序列+1，得到补码）
//
//	// 整数在内存中存储的是补码，在CPU内计算的是补码，在屏幕上输出的是原码
//
//	int a = 0;  // 可以理解0为正整数
//	// 00000000000000000000000000000000 - 0在内存中的补码
//	// 11111111111111111111111111111111 - 补码按位取反，得到存储在计算机内的补码
//	// 11111111111111111111111111111110 - 反码
//	// 10000000000000000000000000000001 - 原码（-1）
//	printf("%d\n", ~a);  // 输出结果是-1
//
//	return 0;
//}

//int main()  // 前置--/++
//{
//	int a = 2;
//	int b = --a;  // 先减减后使用，a=1，b=1
//	printf("%d\n", a);  // 1
//	printf("%d\n", b);  // 1
//
//	return 0;
//}

//int main()  // 后置--/++
//{
//	int a = 2;
//	int b = a++;  // 先使用后加加，b=2，a=3
//	printf("%d\n", a);  // 3
//	printf("%d\n", b);  // 2
//
//	return 0;
//}

//int main()  // 错误或不可取的代码
//{
//	int a = 1;
//	int b = (++a) + (++a) + (++a);
//	printf("b = %d\n", b);
//
//	int c = 10;
//	printf("%d %d\n", --c, --c);
//
//	return 0;
//}

//int main()  // 强制类型转换
//{
//	int a = (int)3.14;
//	printf("%d\n", a);
//
//	return 0;
//}

//int main()  // 逻辑与
//{
//	int a = 3;
//	int b = 5;
//	if ((a == 3) && (b == 4))  // 如果a==3并且b==4，输出haha
//	{
//		printf("haha\n");  // 有一个条件为假，不输出haha
//	}
//
//	return 0;
//}

//int main()  // 逻辑或
//{
//	int a = 3;
//	int b = 5;
//	if ((a == 3) || (b == 4))  // 如果a==3或者b==4，输出hehe
//	{
//		printf("hehe\n");  // 有一个条件为真，输出hehe
//	}
//
//	return 0;
//}

//int main()  // 条件操作符
//{
//	int a = 10;
//	int b = 0;
//
//	if (a == 5)
//	{
//		b = -6;
//	}
//	else
//	{
//		b = 6;
//	}
//
//	b = (a == 5 ? -6 : 6);
//
//	return 0;
//}

//int main()  // 逗号表达式
//{
//	int a = 0;
//	int b = 3;
//	int c = -1;
//	// 逗号表达式会从左向右依次计算，整个逗号表达式的结果是最后一个表达式的结果
//	int d = (a = b - 5, b = a + c, c = a + b, c -= 5);
//	// a=-2，b=-3，c=-10，最后表达式结果为-10赋值给d
//	printf("%d\n", d);
//
//	return 0;
//}

//int main()  // 下标引用操作符
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };  // 定义数组时，[]不是操作符
//	// 下标引用范围[0, 9]
//	arr[9];  // 两个操作数arr 9
//
//	return 0;
//}

//int Add(int x, int y)
//{
//	return x + y;
//}
//
//int main()  // 函数调用操作符
//{
//	int ret = Add(3, 5);  // 操作数个数不确定，函数名+参数个数
//	printf("hehe\n");  // 两个操作数printf "hehe\n"
//
//	return 0;
//}

//int main()  // auto
//{
//	int a = 10;
//	auto int b = 10;  // 局部变量 - 自动变量 - 自动创建，自动销毁，通常省略
//
//	return 0;
//}

//typedef unsigned int u_int;  // 类型重定义，相当于起别名（小名）
//
//int main()  // typedef
//{
//	unsigned int num1 = 100;  // 觉得unsigned int太长，创建变量麻烦，可以使用typedef重定义
//	u_int num2 = 200;  // u_int与unsigned int等价
//
//	return 0;
//}

//int main()  // register
//{
//	register int num = 100;  // 建议编译器将变量存储在寄存器中，以便提高访问速度
//
//	// 既然num放在寄存器里，所以num是不能取地址的，取地址会报错
//	&num;  // err - 取地址是取内存的地址，而寄存器不是内存
//	return 0;
//}

//void test()  // static修饰局部变量
//{
//	// static修饰局部变量改变了变量的生命周期，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束
//	static int a = 1;
//	a++;
//	printf("%d ", a);
//}
//
//int main()
//{
//	int i = 0;
//	while (i < 10)
//	{
//		test();
//		i++;
//	}
//
//	return 0;
//}

//extern int g_val;  // extern声明外部符号
//
//int main()  // static修饰全局变量
//{
//	printf("%d\n", g_val);
//
//	return 0;
//}

//extern int Add(int, int);  // extern声明外部符号
//
//int main()  // static修饰函数
//{
//	int a = 10;
//	int b = 20;
//	int c = Add(a, b);
//	printf("%d\n", c);
//
//	return 0;
//}

//#define NUM 100
//
//int main()  // #define定义常量
//{
//	printf("%d\n", NUM);
//	return 0;
//}

#define MAX(X, Y) (X > Y ? X : Y)

int main()  // #define定义宏
{
	int a = 10;
	int b = 20;

	int c = MAX(a, b);  // int c = (a > b ? a : b);
	// 类似于替换，将参数替换到宏里面去，再进行计算
	// 如果MAX(a+2, b)，不会去算a+2的值，而是直接把a+2传到宏的变量里面去，因此可能会涉及到运算符优先级的问题
	printf("%d\n", c);

	return 0;
}